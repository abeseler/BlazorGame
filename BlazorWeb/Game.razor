@using System.Diagnostics
@using System.Security.Cryptography
@using BlazorWeb.Logic
@using System.Text.Json

@inject IJSRuntime JSRuntime
@implements IDisposable
@page "/"

<PageTitle>Game Test</PageTitle>

<div style="margin:auto;width:@(GameState.MapSize.Width)px">
    <h1 style="color:#F0F0F0;text-align:center">Blazor Game Prototype</h1>
    <div id="viewWindow" style="position:relative;overflow:hidden;background-color:#222222;border-radius:4px;height:@(GameState.TILE_SIZE * 13)px;width:@(GameState.TILE_SIZE * 17)px">
        <div id="gameMap" style="position:absolute;overflow:hidden;height:@(GameState.MapSize.Height)px;width:@(GameState.MapSize.Width)px">
            <div id="gameGrid" style="position:absolute;z-index:0;display:grid;grid-template-columns:repeat(40, 64px)">
                @for(var row = 0; row < 40; row++)
                {
                    @for (var col = 0; col < 40; col++)
                    {
                        <div style="height:62px;width:62px;border:1px dashed #333333;color:#666666;font-size:12px;line-height:62px;vertical-align:middle;text-align:center">@row - @col</div>
                    }
                }
            </div>

            @foreach (var obj in GameState.GameObjects)
            {
                <div id="@obj.Id" style="@GameObjectBoxStyle(obj)">
                    <img src="@obj.Sprite" style="@GameObjectStyle(obj)" />
                </div>
            }
        </div>
    </div>

    <div style="margin-top:16px"><button @onclick=@TogglePause>@(isPaused ? "Resume" : "Pause")</button></div>
</div>

@code {
    private const double MS_PER_UPDATE = 10;
    private const double MS_PER_OFFSET_CHANGE = 250;
    private int spriteOffset = 0;
    private int spriteOffsetIncrement = 1;
    private long lastOffsetChange = Stopwatch.GetTimestamp();
    private long previous = Stopwatch.GetTimestamp();
    private double lag = 0.0;
    private Timer? timer;
    private int viewportWidth;
    private int viewportHeight;
    private bool isPaused = true;

    protected override void OnInitialized() => timer = new Timer(OnElapsedTime, null, 0, 1);

    private void OnElapsedTime(object? state)
    {
        if (isPaused is false)
        {
            var current = Stopwatch.GetTimestamp();
            var elapsed = Stopwatch.GetElapsedTime(previous, current);
            previous = current;
            lag += elapsed.TotalMilliseconds;

            while (lag >= MS_PER_UPDATE)
            {
                GameState.Update();
                lag -= MS_PER_UPDATE;
            }
        }
        Render();
    }

    private void Render()
    {
        var current = Stopwatch.GetTimestamp();
        if (Stopwatch.GetElapsedTime(lastOffsetChange, current).TotalMilliseconds >= MS_PER_OFFSET_CHANGE)
        {
            lastOffsetChange = current;
            if (spriteOffset == 0) spriteOffsetIncrement = 1;
            else if (spriteOffset == 2) spriteOffsetIncrement = -1;

            spriteOffset += spriteOffsetIncrement;
        }
        StateHasChanged();
    }

    private void TogglePause()
    {
        previous = Stopwatch.GetTimestamp();
        isPaused = !isPaused;
    }

    private string GameObjectBoxStyle(GameObject obj) =>
        $"position:absolute;overflow:hidden;top:{obj.Position.Y}px;left:{obj.Position.X}px;height:{obj.Size.Height}px;width:{obj.Size.Width}px;z-index:{obj.Layer}";
    private string GameObjectStyle(GameObject obj) =>
        $"position:absolute;top:{(int)obj.Direction * obj.Size.Height * -1}px;left:{obj.Size.Width * spriteOffset * -1}px;height:{obj.Size.Height * 4}px;width:{obj.Size.Width * 3}px;z-index:{obj.Layer}";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("window.registerViewportChangeCallback", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("window.registerKeyDownCallback", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("window.registerKeyUpCallback", DotNetObjectReference.Create(this));
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnResize(int width, int height)
    {
        if (viewportWidth == width && viewportHeight == height) return;
        viewportWidth = width;
        viewportHeight = height;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnKeyUp(string keyCode) => GameState.KeysActive.Remove(keyCode);

    [JSInvokable]
    public void OnKeyDown(string keyCode) => GameState.KeysActive.Add(keyCode);

    public void Dispose()
    {
        timer?.Dispose();
        GC.SuppressFinalize(this);
    }
}
