@using System.Diagnostics
@using System.Security.Cryptography

@inject IJSRuntime JSRuntime
@implements IDisposable
@page "/"

<PageTitle>Game Test</PageTitle>

<div style="margin:auto;width:@(mapWidth)px">
    <div style="background-color:#222222;position:relative;overflow:hidden;height:@(mapHeight)px;width:@(mapWidth)px">
        @foreach (var box in renderables)
        {
            <div style="position:absolute;top:@(box.Y)px;left:@(box.X)px;height:@(box.Height)px;width:@(box.Width)px;background-color:@box.Color"></div>
        }
    </div>

    <div style="margin-top:16px"><button @onclick=@TogglePause>@(isPaused ? "Resume" : "Pause")</button></div>
</div>


@code {
    private Box[] renderables = new Box[120];

    private const double MS_PER_UPDATE = 10;
    private long previous = Stopwatch.GetTimestamp();
    private double lag = 0.0;
    private Timer? timer;
    private HashSet<string> keysActive = new();
    private int viewportWidth;
    private int viewportHeight;
    private int mapHeight = 1200;
    private int mapWidth = 1200;
    private double frameCount;
    private double totalDuration;
    private bool isPaused = true;

    protected override void OnInitialized()
    {
        for (var i = 0; i < renderables.Length; i++)
        {
            var r = RandomNumberGenerator.GetInt32(0, 255);
            var g = RandomNumberGenerator.GetInt32(0, 255);
            var b = RandomNumberGenerator.GetInt32(0, 255);
            renderables[i] = new Box(0, i * 10)
            {
                Width = 50,
                Height = 10,
                Color = $"rgb({r},{g},{b})",
                Speed = RandomNumberGenerator.GetInt32(2, 6)
            };
        }
        
        timer = new Timer(OnElapsedTime, null, 0, 1);
    }

    private void OnElapsedTime(object? state)
    {
        if (isPaused) return;
        var current = Stopwatch.GetTimestamp();
        var elapsed = Stopwatch.GetElapsedTime(previous, current);
        previous = current;
        lag += elapsed.TotalMilliseconds;

        while (lag >= MS_PER_UPDATE)
        {
            Update();
            lag -= MS_PER_UPDATE;
        }

        Render();
        frameCount++;
        totalDuration += elapsed.Milliseconds;
    }

    private void Update()
    {
        foreach (var box in renderables)
        {
            if (box.X + box.Width >= mapWidth)
            {
                var r = RandomNumberGenerator.GetInt32(0, 255);
                var g = RandomNumberGenerator.GetInt32(0, 255);
                var b = RandomNumberGenerator.GetInt32(0, 255);
                box.Speed = RandomNumberGenerator.GetInt32(2, 6);
                box.Color = $"rgb({r},{g},{b})";
                box.Direction = 1;
            }
            else if (box.X <= 0)
            {
                var r = RandomNumberGenerator.GetInt32(0, 255);
                var g = RandomNumberGenerator.GetInt32(0, 255);
                var b = RandomNumberGenerator.GetInt32(0, 255);
                box.Speed = RandomNumberGenerator.GetInt32(2, 6);
                box.Color = $"rgb({r},{g},{b})";
                box.Direction = 0;
            }

            if (box.Direction == 0)
            {
                box.MoveRight(mapWidth);
            }
            else if (box.Direction == 1)
            {
                box.MoveLeft(mapWidth);
            }
        }
    }

    private void TogglePause()
    {
        previous = Stopwatch.GetTimestamp();
        isPaused = !isPaused;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("window.registerViewportChangeCallback", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("window.registerKeyDownCallback", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("window.registerKeyUpCallback", DotNetObjectReference.Create(this));
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnResize(int width, int height)
    {
        if (viewportWidth == width && viewportHeight == height) return;
        viewportWidth = width;
        viewportHeight = height;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnKeyUp(string keyCode)
    {
        keysActive.Remove(keyCode);
    }

    [JSInvokable]
    public void OnKeyDown(string keyCode)
    {
        keysActive.Add(keyCode);
    }

    private void Render()
    {
        StateHasChanged();
    }

    public void Dispose()
    {
        timer?.Dispose();
        GC.SuppressFinalize(this);
    }

    private class Box(double startX, double startY)
    {
        private double x = startX;
        private double y = startY;

        public int X => (int)x;
        public int Y => (int)y;
        public int Width { get; set; }
        public int Height { get; set; }
        public string? Color { get; set; }
        public double Speed { get; set; }
        public int Direction { get; set; }

        public void MoveUp(int max) => y = Math.Clamp(y - Speed, 0, max - Height);
        public void MoveDown(int max) => y = Math.Clamp(y + Speed, 0, max - Height);
        public void MoveLeft(int max) => x = Math.Clamp(x - Speed, 0, max - Width);
        public void MoveRight(int max) => x = Math.Clamp(x + Speed, 0, max - Width);
    }
}
