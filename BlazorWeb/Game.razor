@using System.Diagnostics
@using System.Security.Cryptography
@using BlazorWeb.Logic

@inject IJSRuntime JSRuntime
@implements IDisposable
@page "/"

<PageTitle>Game Test</PageTitle>

<h1 style="color:#F0F0F0;text-align:center">Blazor Game Prototype</h1>
<div style="margin:auto;width:@(GameState.MapSize.Width)px">
    <div style="background-color:#222222;position:relative;overflow:hidden;height:@(GameState.MapSize.Height)px;width:@(GameState.MapSize.Width)px">
        @foreach (var obj in GameState.GameObjects)
        {
            <div style="position:absolute;top:@(obj.Position.Y)px;left:@(obj.Position.X)px;height:@(obj.Size.Height)px;width:@(obj.Size.Width)px;overflow:hidden">
                <img src="@obj.Sprite" style="@GameObjectStyle(obj)" />
            </div>
        }
    </div>

    <div style="margin-top:16px"><button @onclick=@TogglePause>@(isPaused ? "Resume" : "Pause")</button></div>
</div>

@code {
    private const double MS_PER_UPDATE = 10;
    private long previous = Stopwatch.GetTimestamp();
    private double lag = 0.0;
    private Timer? timer;
    private int viewportWidth;
    private int viewportHeight;
    private bool isPaused = true;

    protected override void OnInitialized() => timer = new Timer(OnElapsedTime, null, 0, 1);

    private void OnElapsedTime(object? state)
    {
        if (isPaused) return;
        var current = Stopwatch.GetTimestamp();
        var elapsed = Stopwatch.GetElapsedTime(previous, current);
        previous = current;
        lag += elapsed.TotalMilliseconds;

        while (lag >= MS_PER_UPDATE)
        {
            GameState.Update();
            lag -= MS_PER_UPDATE;
        }

        Render();
    }

    private string GameObjectStyle(GameObject obj) =>
        $"position:absolute;top:{(int)obj.Direction * obj.Size.Height * -1}px;left:-64px;height:{obj.Size.Height * 4}px;width:{obj.Size.Width * 3}px;z-index:{obj.Layer}";

    private void TogglePause()
    {
        previous = Stopwatch.GetTimestamp();
        isPaused = !isPaused;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("window.registerViewportChangeCallback", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("window.registerKeyDownCallback", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("window.registerKeyUpCallback", DotNetObjectReference.Create(this));
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnResize(int width, int height)
    {
        if (viewportWidth == width && viewportHeight == height) return;
        viewportWidth = width;
        viewportHeight = height;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnKeyUp(string keyCode) => GameState.KeysActive.Remove(keyCode);

    [JSInvokable]
    public void OnKeyDown(string keyCode) => GameState.KeysActive.Add(keyCode);

    private void Render() => StateHasChanged();

    public void Dispose()
    {
        timer?.Dispose();
        GC.SuppressFinalize(this);
    }
}
